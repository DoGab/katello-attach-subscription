#!/usr/bin/env ruby

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

# support for bundler, currently commented out
#require 'rubygems'
#require 'bundler/setup'
require 'optparse'
require 'yaml'
require 'apipie-bindings'

@defaults = {
  :noop      => false,
  :uri       => 'https://localhost/',
  :timeout   => 300,
  :user      => 'admin',
  :pass      => 'changeme',
  :org       => 1,
  :usecache  => false,
  :cachefile => 'katello-attach-subscription.cache',
  :debug     => false,
  :search    => nil,
}

@options = {
  :yamlfile  => 'katello-attach-subscription.yaml',
}

# Parse the command line options
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{opts.program_name} [options]"
  opts.version = "0.1"

  opts.on("-U", "--uri=URI", "URI to the Satellite") do |u|
    @options[:uri] = u
  end
  opts.on("-t", "--timeout=TIMEOUT", OptionParser::DecimalInteger, "Timeout value in seconds for any API calls. -1 means never timeout") do |t|
    @options[:timeout] = t
  end
  opts.on("-u", "--user=USER", "User to log in to Satellite") do |u|
    @options[:user] = u
  end
  opts.on("-p", "--pass=PASS", "Password to log in to Satellite") do |p|
    @options[:pass] = p
  end
  opts.on("-o", "--organization-id=ID", "ID of the Organization") do |o|
    @options[:org] = o
  end
  opts.on("-c", "--config=FILE", "configuration in YAML format") do |c|
    @options[:yamlfile] = c
  end
  opts.on("-n", "--noop", "do not actually execute anything") do
    @options[:noop] = true
  end
  opts.on("-H", "--used-hypervisors-only", "only search for hypervisors that are in use") do
    @options[:search] = 'virtual_guests:*'
  end
  opts.on("-s", "--search=SEARCH", "search for machines matching this string only") do |s|
    @options[:search] = s
  end
  opts.on("--use-cache", "use cache file") do
    @options[:usecache] = true
  end
  opts.on("--cache-file=FILE", "read or write to cache file, based on --use-cache value") do |cf|
    @options[:cachefile] = cf
  end
  opts.on("-d", "--debug", "debug the script") do
    @options[:debug] = true
  end
end
optparse.parse!

# load the configuration files settings
@yaml = YAML.load_file(@options[:yamlfile])

# override configuration files settings with command lines one
if @yaml.has_key?(:settings) and @yaml[:settings].is_a?(Hash)
  @yaml[:settings].each do |key,val|
    if not @options.has_key?(key)
      @options[key] = val
    end
  end
end

# missing configuration parameters from file or command line are taken from the default one
@defaults.each do |key,val|
  if not @options.has_key?(key)
    @options[key] = val
  end
end

# main function
def vdcupdate()
  # TODO add sanity check for https. If the url is http the following will error will be shoun in production.log
  # 2016-07-27 19:30:17 [I] Filter chain halted as #<Proc:0x00000007d88298@/opt/rh/ruby193/root/usr/share/gems/gems/actionpack-3.2.8/lib/action_controller/metal/force_ssl.rb:28> rendered or redirected

  # create api binding
  api = ApipieBindings::API.new({:uri => @options[:uri], :username => @options[:user], :password => @options[:pass], :api_version => '2', :timeout => @options[:timeout]})

  # initialize variables
  systems = []
  subs = {}
  page = 0
  req = nil

  # Fill systems array from API of satellite. Check for cache usage.
  if @options[:usecache] and File.file?(@options[:cachefile])
    # TODO need sanity check, what if file do not exits? what if value are not valid?
    # TODO use one cache file for each organization, otherwise cache is broken
    systems = YAML.load_file(@options[:cachefile])
  else
    # no cache wanted or no cache file exists
    # checking all of the systems 100 at the time, from page 0 to latest
    while (page == 0 or req['results'].length == req['per_page'].to_i)
      # increase page counter
      page += 1
      # get 100 results
      # filter to be applied: organization, and search options
      req = api.resource(:systems).call(:index, {:organization_id => @options[:org], :page => page, :per_page => 100, :search => @options[:search]})
      # concatenate output - all of the results
      systems.concat(req['results'])
    end
    # always write the cache file, even if not asked, to be used in the future
    File.open(@options[:cachefile], 'w') {|f| f.write(YAML.dump(systems)) }
  end

  # cycle for each system found
  systems.each do |system|
    # get detail for each system
    if @options[:debug]
      puts "DEBUG: detail of the current system to be checked:"
      p system
    end
    sys = api.resource(:systems).call(:show, {:id => system['id'], :fields => 'full'})
    # add to array system the name of the system itself taken from id
    puts "Current system: #{system['name']} (#{system['id']})"

    has_desired_sub = nil 
    desired_sub = nil 
    desired_sub_hash = nil
    desired_type = 'Hypervisor'
    remove_other = true
    # for each item in yaml extract sub
    if @options[:debug]
      puts "DEBUG: YAML dump"
      p @yaml
    end
    @yaml[:subs].each do |sub|
      # if "type" has been specified on yaml file check if match.
      # the default is to check on "Hypervisor"
      # if DO NOT match, skip to next sub
      if sub.has_key?('type')
        desired_type = sub['type']
      end
      if sys['type'] != desired_type
        puts "Skipping '#{system['name']}' as type '#{sys['type']}' != '#{desired_type}'"
        next
      end

      # if "registered_by" has been specified on yaml file check if match.
      # the default is to not check it, any value will be good
      # if DO NOT match, skip to next sub
      if sub.has_key?('registered_by') and sub['registered_by']
        if sub['registered_by'] != system['registered_by']
          puts "Skipping '#{system['name']}' as the system has registered_by '#{system['registered_by']}' while '#{sub['registered_by']}' is requested"
          next
        end
      end

      # extract the name of the host to be registered
      hostnameregex = Regexp.new(sub['hostname'])
      if @options[:debug]
        puts "DEBUG: Current host: '#{sub['hostname'].inspect}', looking for pattern '#{hostnameregex.inspect}'"
      end
      # check against the current system item
      if hostnameregex.match(system['name'])
        # set the desidered subscription to be associated
        desired_sub_hash = sub['sub']
        # if "remove_other" has been set, set the flag
        if sub.has_key?('remove_other')
          remove_other = sub['remove_other']
        end
        # if the system is found, stop cyclyng over yaml, 
        break
      end
    end

    # check if any hosts has a match
    if @options[:debug]
      puts "DEBUG: desired_sub_hash value"
      p desired_sub_hash
    end
    if desired_sub_hash
      puts " Adding subscription for #{system system['id']}"
      has_desired_sub_hash = {}
      # check the current subscription associated to one system
      if api.has_resource?(:host_subscriptions)
        req = api.resource(:host_subscriptions).call(:index, {:organization_id => @options[:org], :host_id => system['host_id'], :per_page => 100})
      else
        req = api.resource(:subscriptions).call(:index, {:organization_id => @options[:org], :system_id => system['id'], :per_page => 100})
      end
      # we need to check for each product the needed subs
      desired_sub_hash.each do |product, desidered_product_sub_array|
        puts "in the desired_sub_hash #{desidered_product_sub_array}"
        has_desired_sub = false
        # for each subscription do
        req['results'].each do |sub|
          if @options[:debug]
            puts "DEBUG: current sub"
            p sub
          end
          # move subscription_id key to cp_id, to have the API standard
          if (sub.has_key?('subscription_id'))
            sub['cp_id'] = sub.delete('subscription_id')
          end
          if @options[:debug]
            puts "DEBUG: sub after modification of cp_id"
            p sub
            #p desidered_product_sub_array
            #p desired_sub_hash
            p desired_sub_hash.flatten(2)
          end
          # WORKAROUND even if checking the current array of licence is correct, from a formal point of view, using multiple product 
          # because of this bug, currently we are looking for the sub_id into the full hash, since this is unique
          #if desidered_product_sub_array.include?(sub['cp_id'])
          if desired_sub_hash.flatten(2).include?(sub['cp_id'])
            #puts " the desired subscriptio #{sub['cp_id']} for #{product} product is already associated in the list of subscriptions valid for this product #{desidered_product_sub_array}"
            puts " subscription #{sub['cp_id']} for #{product} product is already attached to #{system['id']}"
            #has_desired_sub_hash << desired_product_sub_array
            has_desired_sub = true
          # else, if this is not the one desidered, and remove_other is set, remove the current subscription
          elsif remove_other and sub['cp_id'] != nil
            puts " removing #{sub['cp_id']}"
            if not @options[:noop]
              if api.has_resource?(:host_subscriptions)
                api.resource(:host_subscriptions).call(:remove_subscriptions, {:host_id => system['host_id'], :subscriptions => [{:id => sub['id']}]})
              else
                api.resource(:subscriptions).call(:destroy, {:system_id => system['id'], :id => sub['id']})
              end
              puts " removed"
            else
              puts " [noop] removed"
            end
          end
        end
        if not has_desired_sub
          puts "sub for product " + product.to_s + " currently missing"
          has_desired_sub_hash[product] = desidered_product_sub_array
        end
      end
 
     if @options[:debug]
       puts "DEBUG: has_desired_sub_hash: #{has_desired_sub_hash}"
     end

      # if the content host do not has subscrition, or the "needed" one, attach it
      if has_desired_sub_hash
        has_desired_sub_hash.each do |product, desired_subs_hash|
          desired_subs_hash.each do |desired_sub|

            if @options[:debug]
              puts "DEBUG: current subscription to be checked"
              p desired_sub
            end
            # if the subs do not exist, the following error is given, with error 400 on API
            # 2016-07-27 16:43:19 [E] RestClient::ResourceNotFound: Katello::Resources::Candlepin::Pool: 404 Resource Not Found {"displayMessage":"Pool with id 4543828edcf35158c30abc3554c1e36a could not be found.","requestUuid":"d9b83468-0ef7-4d59-940b-7b50e98520dc"} (GET /candlepin/pools/4543828edcf35158c30abc3554c1e36a)
            subs[desired_sub] ||= api.resource(:subscriptions).call(:show, {:id => desired_sub, :organization_id => @options[:org]})
            # TODO ADD id in the array and a check before to call show only if the hash is not populated
            desired_sub_id = subs[desired_sub]['id']
            # TODO where Satellite may report the socket number, do the math
            desired_quantity = 1
            if desired_quantity > subs[desired_sub]['available'].to_i
              puts " cannot add #{desired_sub} (id: #{desired_sub_id}): only #{res['available']} available, but #{desired_quantity} requested"
              next
            end
            puts " adding #{desired_sub} for #{product} (id: #{desired_sub_id})"
  
            subs[desired_sub]['available'] -= desired_quantity
            subs[desired_sub]['consumed'] += desired_quantity

            if not @options[:noop]
              begin
                if api.has_resource?(:host_subscriptions)
                  api.resource(:host_subscriptions).call(:add_subscriptions, {:host_id => system['host_id'], :subscriptions => [{:id => desired_sub_id, :quantity => desired_quantity}]})
                else
                  api.resource(:subscriptions).call(:create, {:system_id => system['id'], :subscriptions => [{:id => desired_sub, :quantity => desired_quantity}]})
                end
                puts " added #{desired_sub} for #{product} in system #{system['id']}"
                break
              # need to check the return code and if fail go to next licence in the pool
              rescue Exception => e
                puts "FATAL ERROR: unable to attach subscription, please inform developers"
                puts e.message
                puts e.backtrace.inspect
                exit
                #if @options[:debug]
                #  puts "unable to attach subscription, do be debugged"
                  #end
                next
              end
            else
              puts " [noop] added #{desired_sub} for #{product} in system #{system['id']}"
              break
            end
          end
        end
      end
    end
  end
end

vdcupdate
